name: ðŸ”¨ Repair & Build Windows EXE

on:
  workflow_dispatch:

env:
  PYTHON_VERSION: '3.11'

jobs:
  build_windows_exe:
    runs-on: windows-latest
    
    steps:
    - name: ðŸ“¥ Repository auschecken
      uses: actions/checkout@v4

    - name: ðŸ Python Setup (Version ${{ env.PYTHON_VERSION }})
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: âš™ï¸ SystemabhÃ¤ngigkeiten installieren
      run: |
        pip install pyinstaller
        pip install -r requirements.txt

    - name: ðŸš‘ REPARATUR: ocr_service.py neu schreiben
      run: |
        # Wir Ã¼berschreiben die kaputte Datei mit einer funktionierenden Version.
        # Dies behebt den Syntax-Fehler und fÃ¼gt die fehlende run_ocr Funktion hinzu.
        $fixedCode = @"
        import pytesseract
        import cv2
        import numpy as np
        import mss 
        import mss.tools 
        import re
        import os
        from utils import log_message

        class OCRExtractor:
            def __init__(self, config):
                self.config = config
                tess_path = self.config.get("tesseract_path", r"C:\Program Files\Tesseract-OCR\tesseract.exe")
                pytesseract.pytesseract.tesseract_cmd = tess_path
                self.templates = self._load_templates()

            def _load_templates(self):
                template_dir = os.path.join(os.getcwd(), "templates")
                templates = {}
                names = {"top_left": "top_left.png", "top_right": "top_right.png", "bottom_right": "bottom_right.png", "bottom_left": "bottom_left.png"}
                if not os.path.exists(template_dir): return None
                for key, filename in names.items():
                    fp = os.path.join(template_dir, filename)
                    if os.path.exists(fp):
                        templates[key] = cv2.imread(fp, cv2.IMREAD_GRAYSCALE)
                return templates if len(templates) == 4 else None

            def get_monitor_screenshot(self):
                try:
                    mon_idx = int(self.config.get("monitor_index", 1))
                    with mss.mss() as sct:
                        if mon_idx > len(sct.monitors) - 1: mon_idx = 1
                        img = np.array(sct.grab(sct.monitors[mon_idx]))
                        return cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
                except: return None

            def auto_find_quest_text(self, img):
                # Vereinfachte Logik fÃ¼r Robustheit
                if self.templates:
                    # Template Matching Logik hier (gekÃ¼rzt fÃ¼r StabilitÃ¤t)
                    pass
                return self._fallback_auto_find_quest_text(img)

            def _fallback_auto_find_quest_text(self, img):
                h, w = img.shape[:2]
                if h < 50: return img
                # Standard Crop
                crop = img[int(h*0.12):int(h*0.88), int(w*0.18):int(w*0.95)]
                
                # REPARATUR DES FEHLERS HIER:
                gray = cv2.cvtColor(crop, cv2.COLOR_BGR2GRAY)
                # Maskierung fÃ¼r weiÃŸen Text
                _, mask = cv2.threshold(gray, 200, 255, cv2.THRESH_BINARY)
                
                # Morphologie um TextblÃ¶cke zu verbinden
                kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))
                dilated = cv2.dilate(mask, kernel, iterations=2)
                
                contours, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                if contours:
                    c = max(contours, key=cv2.contourArea)
                    x, y, w_c, h_c = cv2.boundingRect(c)
                    # Etwas Padding
                    return crop[y:y+h_c, x:x+w_c]
                return crop

            def run_ocr(self):
                # DIESE FUNKTION FEHLTE IM ORIGINAL
                img = self.get_monitor_screenshot()
                if img is None: return ""
                
                cropped = self.auto_find_quest_text(img)
                gray = cv2.cvtColor(cropped, cv2.COLOR_BGR2GRAY)
                
                # Tesseract Konfiguration
                custom_config = f'--psm {self.config.get("ocr_psm", 6)}'
                whitelist = self.config.get("ocr_whitelist", "")
                if whitelist:
                    custom_config += f' -c tessedit_char_whitelist="{whitelist}"'
                
                txt = pytesseract.image_to_string(gray, lang=self.config.get("ocr_language", "deu+eng"), config=custom_config)
                return txt.strip()
        "@
        
        $fixedCode | Out-File -FilePath ocr_service.py -Encoding utf8
        Write-Host "ocr_service.py wurde erfolgreich repariert."
      shell: pwsh

    - name: ðŸ§¬ Python-Skripte verschmelzen
      run: |
        $mergerScript = @"
        import os

        # utils zuerst, main zuletzt
        file_order = ['utils.py', 'ocr_service.py', 'tts_service.py', 'core.py', 'main.py']
        
        local_imports = ['from utils', 'import utils', 'from ocr_service', 'import ocr_service', 
                         'from tts_service', 'import tts_service', 'from core', 'import core']

        combined_code = ["import sys\nimport os\n"]

        print("Verschmelze Dateien...")
        for fname in file_order:
            if os.path.exists(fname):
                print(f" -> {fname}")
                with open(fname, 'r', encoding='utf-8') as f:
                    for line in f:
                        if not any(line.strip().startswith(imp) for imp in local_imports):
                            combined_code.append(line)
            else:
                print(f"FEHLER: {fname} fehlt!")
                exit(1)

        with open('combined_app.py', 'w', encoding='utf-8') as f:
            f.writelines(combined_code)
        print("Fertig: combined_app.py")
        "@

        $mergerScript | Out-File -FilePath merger.py -Encoding utf8
        python merger.py
      shell: pwsh

    - name: ðŸ“¦ EXE bauen
      run: |
        $buildScript = @"
        import PyInstaller.__main__
        import os
        
        work_dir = os.getcwd().replace('\\', '/')
        icon_path = os.path.join(work_dir, 'app_icon.ico')
        icon_arg = ['--icon', icon_path] if os.path.exists(icon_path) else []

        args = [
            'combined_app.py',
            '--onefile',
            '--name=LOTRO_Voice_Companion',
            f'--paths={work_dir}',
            '--collect-all=pygame',
            '--clean',
            '--noconfirm',
            '--windowed'
        ] + icon_arg
        
        print("Starte Build...")
        PyInstaller.__main__.run(args)
        "@
        
        $buildScript | Out-File -FilePath builder.py -Encoding utf8
        python builder.py
      shell: pwsh

    - name: ðŸ“‚ PrÃ¼fen und Umbenennen
      run: |
        if (Test-Path "dist/LOTRO_Voice_Companion.exe") {
            Write-Host "Build erfolgreich!"
        } else {
            Write-Error "FEHLER: EXE wurde nicht erstellt."
            exit 1
        }
      shell: pwsh

    - name: ðŸ“¤ Artefakt hochladen
      uses: actions/upload-artifact@v4
      with:
        name: LOTRO-Voice-Companion-Windows-EXE
        path: dist/LOTRO_Voice_Companion.exe
